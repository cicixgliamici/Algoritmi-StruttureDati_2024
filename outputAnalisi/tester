/**
/* 5 Strutture dati   Ingredienti:      AVL di min-Heap  -> Ingredienti ordinati per scadenza nel min-Heap
*                     Ricette:          BST di liste     -> Ordinamento lessicografico
*                     Ordini da Fare:   Coda FIFO        -> Mantiene l'ordine di arrivo degli ordini
*                     Ordini fatti:     min-Heap         -> Istante di arrivo dell'ordine
*                     Camioncino:       max-Heap         -> Peso totale dell'ordine (a parità di peso, istante di arrivo)
*/
#ifndef HEADER_H
#define HEADER_H
#include <stdio.h>
#include <stdbool.h>

// Ingredienti - Heap - ordino tutti i prodotti dello stesso tipo per scadenza(asc), così da rispettare la specifica
//                      è presente un puntatore al suo nodo per aggiornare il peso_totale del nodo
typedef struct IngredienteMinHeap {
    int scadenza;
    int quantita;
    struct NodoAVL* nodoAVL;
} IngredienteMinHeap;

typedef struct {
    IngredienteMinHeap* lotto;
    int dimensione;
    int capacita;
} MinHeapIngrediente;

void scambia(IngredienteMinHeap* a, IngredienteMinHeap* b);                                                    //Scambia due elementi
void heapifyIngredienti(MinHeapIngrediente* heap, int i);                                                      //Riordina gli elementi
void inserisciIngrediente(MinHeapIngrediente* heap, int scadenza, int quantita, struct NodoAVL* nodo);         //Inserisce un ingrediente
void liberaLotto(MinHeapIngrediente* heap);                                                                    //Libera la memoria
IngredienteMinHeap rimuoviIngrediente(MinHeapIngrediente* heap);                                               //Rimuove e ritorna l'ingrediente
MinHeapIngrediente nuovoHeapIngredienti(int capacita);                                                         //Inizializza un nuovo heap (e restituisce il suo puntatore)

//Ingredienti - AVL - ordino i lotti di ingredienti lessicograficamente(disc), per velocizzare aggiunta, eliminazione e ricerca
typedef struct NodoAVL {
    char nome[256];
    MinHeapIngrediente heap;
    struct NodoAVL *sinistro;
    struct NodoAVL *destro;
    int altezza;
} NodoAVL;

void liberaAVL(NodoAVL *root);                                                                  //Libera la memoria
int valBilancia(NodoAVL *nodo);                                                                 //Calcola e ritorna il valore di bilanciamento di un nodo
int altezza(NodoAVL *nodo);                                                                     //Calcola e ritorna l'altezza di un nodo
NodoAVL* nuovoAVL(char* nome, int capacita);                                                    //Crea un nuovo nuodo (e restituisce il suo puntatore)
NodoAVL* ruotaDestra(NodoAVL *y);                                                               //Esegue una rotazione a destra
NodoAVL* ruotaSinistra(NodoAVL *x);                                                             //Esegue una rotazione a sinistra
NodoAVL* minValueAVL(NodoAVL *nodo);                                                            //Trova e ritorna il nodo con il valore minimo in un AVL (puntatore)
NodoAVL* eliminaAVL(NodoAVL* root, char *nome);                                                 //Elimina un nodo
NodoAVL* cercaAVL(NodoAVL* nodo, const char* nome);                                             //Cerca un nodo
NodoAVL* inserisciAVL(NodoAVL* nodo, char* nome, int scadenza, int quantita, int capacita);     //Inserisce un nodo (da bilanciare)
NodoAVL* bilanciaAVL(NodoAVL *nodo);                                                            //Bilancia il nodo inserito

//Ricette - Lista
typedef struct IngredienteRicetta {
    char nome[256];
    int quantita;
    struct IngredienteRicetta *next;
} IngredienteRicetta;

typedef struct Ricetta {
    char nome[256];
    IngredienteRicetta *ingredienti;
} Ricetta;

//Ricette - BST
typedef struct NodoBST {
    Ricetta ricetta;
    struct NodoBST *sinistro;
    struct NodoBST *destro;
} NodoBST;

void liberaBST(NodoBST* root);                                 //Libera la memoria del nodo
void liberaListaIng(IngredienteRicetta* ingrediente);          //Libera la memoria della lista di ingredienti di un nodo
NodoBST* nuovoBST(Ricetta ricetta);                            //Crea un nuovo nodo (e restituisce il suo puntatore)
NodoBST* minValueBST(NodoBST* nodo);                           //Trova e ritorna il nodo con il valore minimo in un BST (puntatore)
NodoBST* inserisciBST(NodoBST* nodo, Ricetta ricetta);         //Inserisce un nodo
NodoBST* cercaBST(NodoBST* nodo, char* nome);                  //Cerca un nodo
NodoBST* eliminaBST(NodoBST* root, char* nome);                //Elimina un nodo

//Ordine da Fare - Coda FIFO
typedef struct Ordine {
    int tempo_arrivo; // Identificatore unico dell'ordine
    char nome_ricetta[256];
    int quantita;
    struct Ordine* next;
} Ordine;

typedef struct {
    Ordine* testa;
    Ordine* coda;
} CodaOrdini;

void liberaCoda(CodaOrdini* coda);                                                          //Libera la memoria
void aggiungiCoda(CodaOrdini* coda, const char* nome_ricetta, int quantita, int tempo_arrivo);    //Aggiunge un ordine
int codaVuota(CodaOrdini* coda);                                                            //Verifica se la coda è vuota
CodaOrdini* creaCoda();                                                                     //Crea una nuova coda (e restituisce il suo puntatore)
Ordine* rimuoviCoda(CodaOrdini* coda);                                                      //Rimuove e ritorna un ordine dalla coda (puntatore)

//Ordini fatti - minHeap
typedef struct OrdineHeap {
    int tempo_arrivo;
    char ricetta[256];
    int quantita;
} OrdineHeap;

typedef struct {
    OrdineHeap* ordini;
    int dimensione;
    int capacita;
} MinHeap;

void liberaMinHeapOrdini(MinHeap* heap);                                                       //Libera la memoria
void scambiaOrdini(OrdineHeap* a, OrdineHeap* b);                                              //Scambia due ordini
void heapifyOrdini(MinHeap* heap, int i);                                                      //Riordina gli elementi
void inserisciOrdineHeap(MinHeap* heap, int tempo_arrivo, char* nome_ricetta, int quantita);   //Inserisce un ordine
int heapVuotoMinOrdine(MinHeap* heap);                                                         //Verifica se il min-heap è vuoto
MinHeap* creaMinHeap(int capacita);                                                            //Crea un nuovo min-heap (e restituisce il suo puntatore)
OrdineHeap rimuoviMin(MinHeap* heap);                                                          //Rimuove e ritorna l'ordine (puntatore)

//Spedizione - maxHeap
typedef struct Spedizione {
    char nome[256];
    int istante_arrivo;
    int quantita;
    int peso;
} Spedizione;

typedef struct {
    Spedizione* spedizioni;
    int dimensione;
    int capacita;
} MaxHeapSpedizioni;

void heapifySpedizioni(MaxHeapSpedizioni* heap, int i);                                                       //Riordina gli elementi
void inserisciSpedizione(MaxHeapSpedizioni* heap, char* nome, int istante_arrivo, int quantita, int peso);    //Inserisce una spedizione
void liberaMaxHeap(MaxHeapSpedizioni* heap);                                                                  //Libera la memoria
MaxHeapSpedizioni* creaMaxHeap(int capacita);                                                                 // Crea un nuovo max-heap (e restituisce il suo puntatore)
Spedizione rimuoviMax(MaxHeapSpedizioni* heap);                                                               //Rimuove e ritorna la spedizione (puntatore)
int heapVuotoMax(MaxHeapSpedizioni* heap);

//Funzioni Generiche//Attivare tutti i test
int max(int a, int b);

//Funzioni per l'Algoritmo
void gestisciComandi(FILE *file);                                                                //Leggi comando con strcmp
void aggiungi_ricetta(Ricetta nuova_ricetta);                                                    //Controlla se già esiste, se no aggiungi
void rimuovi_ricetta(const char* nome_ricetta);                                                  //Controlla se esiste o se è in ordinazione, se no rimuovi
void rifornimento(const char* comando);                                                          //Nessun controllo
void ordine(const char* nome_ricetta, int numero_elementi_ordinati);                             //Controlla esistenza in ricettario, se si aggiungi a Coda e poi prova a fare

bool fattibilita(const char* nome_ricetta, int numero_elementi_ordinati);                        //Verifica la fattiblità di un ordine guardando peso_totale e peso ordine
void preparazione(const char* nome_ricetta, int numero_elementi_ordinati, int tempo_arrivo);     //Effettua la preparazione rispettando la specifica di rimozione ingredienti scadenza minore
void verificaOrdini();                                                                           //Verifica la fattibilità di tutti gli ordini in Coda
void caricaCamion();                                                                             //Passaggio da minHeap ordini fatti a maxHeap spedizione
int calcolaPeso(Ricetta ricetta, int numero_elementi_ordinati);                                  //Calcola il peso di un ordine
void controllaScadenza(NodoAVL* nodo_ingrediente);
void controllaScadenzaAVL(NodoAVL* nodo);

/* Zona T&S     test:
*
*               stampa:
*/
bool verificaMinHeap(MinHeapIngrediente* heap);                                          //Verifica la correttezza del min-heap
void testHeapOrder(MinHeapIngrediente* heap);                                            //Stampa verificando la correttezza dell'ordine
void testMinHeapInserimento();                                                           //Test di inserimento
void testMinHeapRimozione();                                                             //Test di rimozione
void testMinHeapOverflow();                                                              //Test di overflow
void testMinHeapInit();                                                                  //Test di inizializzazione
void testMinHeapIngrediente();                                                           //Raccoglie i test
void testUsoParzialeIngrediente();                                                       //Test per verificare la correttezza dell'inserimento
void testRifornimentoRicetta();                                                          //Test per verificare la correttezza dell'inserimento(migliore)
void testAggiungiRimuoviIngredienti_AVL();
void testDeallocazioneAVL();
void testCodaOrdini();
void verificaInserimento(NodoAVL* nodo, const char* nome);

void stampaHeapIngredienti1(MinHeapIngrediente* heap);
void stampaHeapIngredienti2(MinHeapIngrediente* heap, int *count);
void stampaAVL1(NodoAVL* nodo);
void stampaAVL2(NodoAVL* nodo, int *count);
void stampaBST1(NodoBST* nodo);
void stampaBST2(NodoBST* nodo, int *count);
int stampaCodaFIFO(CodaOrdini* coda);
void stampaMinHeapOrdini(MinHeap* heap);
void stampaMaxHeapSpedizioni(MaxHeapSpedizioni* heap);
void print_string_info(const char* str);
void stampaTutto();

// Dichiarazione delle variabili globali (rimuovere quando metti tutto insieme)
extern NodoBST* bst;
extern NodoAVL* avl;
extern CodaOrdini* coda_ordini;
extern MinHeap* heap_ordini_fatti;
extern MaxHeapSpedizioni* max_heap_spedizioni;
extern int tempoCorrente;
extern int ultimoAggiornamento;

#endif //HEADER_H


/*  4 Azioni da svolgere   aggiungi_ricetta: devo controllare nel BST se è già presente
*                          rimuovi_ricetta:  devo controllare sia se è presente nel BST sia nelle 3 strutture di ordini
*                          rifornimento:     non devo fare controlli anteriori, ma devo controllare dopo se posso fare ordini sulla coda
*                          ordine:           devo prima controllare se esiste nel BST, se no rifiutare
*                                            poi lo inserisco nella Coda, e se fattibile lo tolgo e metto sul minHeap
*                                            sennò lo tengo in coda ed aspetto ogni rifornimento
*
*   Il Tempo               Ogni azione costituisce un istante di tempo, escluso il setting del camioncino, si parte da t=0
*                          Il riempimento del camion va fatto prima dell'azione, e fatto ad ogni multiplo (anche a riga vuota, vedi esempio specifica), ogni n*tempoCamion multipli
*                          Condiziona anche gli ingredienti con scadenza, che non viene aggiornata ogni istante ma nella funzione "fattibilita"  
*
*   Gestione comandi       Leggo la riga da input con fgets, la salvo e poi la analizzo con sscanf
*                          Aggiorno il tempo ad ogni lettura di riga e per i multipi del tempo camioncino, prima lo carico e poi faccio l'azione
*/
#include "header.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

// Dichiarazione globale delle strutture dati
NodoBST* bst = NULL;
NodoAVL* avl = NULL;
CodaOrdini* coda_ordini = NULL;
MinHeap* heap_ordini_fatti = NULL;
MaxHeapSpedizioni* max_heap_spedizioni = NULL;
int tempoCorrente = -1;
int ultimoAggiornamento = -1;

// Funzioni generiche
int max(int a, int b) {
    return (a > b) ? a : b;
}

// Funzioni Algoritmo
void gestisciComandi(FILE *file) {
    unsigned int tempoCamion, capienzaCamion;
    fscanf(file, "%d %d", &tempoCamion, &capienzaCamion);
    //printf("%d %d\n", tempoCamion, capienzaCamion);
    max_heap_spedizioni = creaMaxHeap(capienzaCamion);                                          //Nel caso peggiore ho capienzaCamion ordini di peso 1
    coda_ordini = creaCoda();
    heap_ordini_fatti = creaMinHeap(10);
    ultimoAggiornamento = 0;
    char line[1000];  //IMPORTANTE
    while (fgets(line, sizeof(line), file)) {
        char command[256];
        if (sscanf(line, "%s", command) == 1) {
            //printf("%s     ", command);
            tempoCorrente++;
            controllaScadenzaAVL(avl);
            //printf("t=%d --->       ", tempoCorrente);
            if(tempoCorrente%tempoCamion==0 && tempoCorrente!=0){
                //stampaTutto();
                caricaCamion();
            }
            if (strcmp(command, "aggiungi_ricetta") == 0) {                                     //Per non portarmi appresso tutta la lista ingredienti faccio il controllo qui
                char nome_ricetta[256];
                if (sscanf(line + strlen(command), "%s", nome_ricetta) == 1) {
                    if (cercaBST(bst, nome_ricetta) != NULL) {
                        printf("ignorato\n");
                    } else {
                        Ricetta nuova_ricetta;
                        strcpy(nuova_ricetta.nome, nome_ricetta);
                        nuova_ricetta.ingredienti = NULL;
                        IngredienteRicetta *tail = NULL;
                        char ingrediente[256];
                        int quantita;
                        char *ptr = line + strlen(command) + strlen(nome_ricetta) + 1;
                        while (sscanf(ptr, "%s %d", ingrediente, &quantita) == 2) {
                            IngredienteRicetta *nuovo_ingrediente = (IngredienteRicetta*)malloc(sizeof(IngredienteRicetta));
                            strcpy(nuovo_ingrediente->nome, ingrediente);
                            nuovo_ingrediente->quantita = quantita;
                            nuovo_ingrediente->next = NULL;
                            if (tail == NULL) {
                                nuova_ricetta.ingredienti = nuovo_ingrediente;
                            } else {
                                tail->next = nuovo_ingrediente;
                            }
                            tail = nuovo_ingrediente;
                            ptr += strlen(ingrediente) + 1 + snprintf(NULL, 0, "%d", quantita) + 1;
                        }
                        aggiungi_ricetta(nuova_ricetta);
                    }
                }
            } else if (strcmp(command, "rimuovi_ricetta") == 0) {
                char nome_ricetta[256];
                if (sscanf(line + strlen(command), "%s", nome_ricetta) == 1) {
                    rimuovi_ricetta(nome_ricetta);
                }
            } else if (strcmp(command, "rifornimento") == 0) {
                //printf("%s\n", line);
                rifornimento(line + strlen(command) + 1);
            } else if (strcmp(command, "ordine") == 0) {
                if(tempoCorrente==23) {
                    //stampaAVL1(avl);
                    //stampaBST1(bst);
                }
                char nome_ricetta[256];
                int quantita;
                if (sscanf(line + strlen(command), "%s %d", nome_ricetta, &quantita) == 2) {
                    ordine(nome_ricetta, quantita);
                }
            }
        }
    }
    if((tempoCorrente+1)%tempoCamion==0 && tempoCorrente!=0)
        caricaCamion();
    //stampaTutto();
}

void aggiungi_ricetta(Ricetta nuova_ricetta) {
    bst = inserisciBST(bst, nuova_ricetta);
    printf("aggiunta\n");
}

void rimuovi_ricetta(const char* nome_ricetta) {
    Ordine* ordine_corrente = coda_ordini->testa;
    while (ordine_corrente != NULL) {                                                   //Controllo nella coda degli ordini da fare
        if (strcmp(ordine_corrente->nome_ricetta, nome_ricetta) == 0) {
            printf("ordini in sospeso\n");
            return;
        }
        ordine_corrente = ordine_corrente->next;
    }
    for (int i = 0; i < heap_ordini_fatti->dimensione; i++) {                           //Controllo nel minHeap degli ordini fatti
        if (strcmp(heap_ordini_fatti->ordini[i].ricetta, nome_ricetta) == 0) {
            printf("ordini in sospeso\n");
            return;
        }
    }
    if (cercaBST(bst, (char*)nome_ricetta) == NULL) {                                          //Controllo nel BST
        printf("non presente\n");
    } else {
        bst = eliminaBST(bst, (char*)nome_ricetta);
        printf("rimossa\n");
    }
}

void rifornimento(const char* comando) {
    char nome_ingrediente[256];
    int quantita, scadenza;
    const char *ptr = comando;
    //printf("%s\n", comando);
    while (sscanf(ptr, "%s %d %d", nome_ingrediente, &quantita, &scadenza) == 3) {
        NodoAVL* nodo = cercaAVL(avl, nome_ingrediente);
        if (nodo != NULL) {
            inserisciIngrediente(&nodo->heap, scadenza, quantita, nodo);
        } else {
            avl = inserisciAVL(avl, nome_ingrediente, scadenza, quantita, 10);
        }
        //printf("Rifornito %s con %d unità, scadenza %d\n", nome_ingrediente, quantita, scadenza); // Debugging
        ptr += strlen(nome_ingrediente) + 1 + snprintf(NULL, 0, "%d", quantita) + 1 + snprintf(NULL, 0, "%d", scadenza) + 1;
    }
    printf("rifornito\n");
    verificaOrdini();
}

// Main - Gestione del giorno
int main(void) {
    FILE *file = fopen("C:/Users/39392/CLionProjects/API/tests/open5.txt", "r"); //stdin
    gestisciComandi(file);
    fclose(file);
    //stampaTutto();
    return 0;
}

/* Gestione degli ordini       ordine:             se non esiste la ricetta, lo rifiuto, altrimenti prima lo aggiungo in coda
*                                                  poi ne verifico la fattibilita ed eventualmente lo preparo
*
*                              fattibilita:        verifica la fattibilita dell'ordine guardando la quantita totale di ingredienti
*                                                  nell'AVL, senza togliere nulla
*
*                              preparazione:       prepara effetivamente l'ordine togliendo sempre gli ingredienti con scadenza minore
*                                                  svuota anche l'heap degli ingredienti scaduti
*
*                              verificaOrdini:     sostanzialmente è la funzione ordine ma chiamata su tutta la coda, usata quando si fa
*                                                  rifornimento
*
*                              caricaCamion:       passa gli ordini dal minHeap (istante arrivo) al maxHeap (peso), si ferma al primo che supera la
*                                                  capacità restante
*
*                              calcolaPeso:        calcola il peso dell'ordine in toto
*/
#include "header.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void ordine(const char* nome_ricetta, int numero_elementi_ordinati) {
    NodoBST* nodo_ricetta = cercaBST(bst, (char*)nome_ricetta);
    if (nodo_ricetta == NULL) {
        printf("rifiutato\n");
        return;
    }
    controllaScadenzaAVL(avl);
    if (fattibilita(nome_ricetta, numero_elementi_ordinati)) {
        preparazione(nome_ricetta, numero_elementi_ordinati, tempoCorrente);
        printf("accettato\n");
    } else {
        aggiungiCoda(coda_ordini, (char*)nome_ricetta, numero_elementi_ordinati, tempoCorrente);
        //stampaCodaFIFO(coda_ordini);
        printf("accettato\n");
    }
}

bool fattibilita(const char* nome_ricetta, int numero_elementi_ordinati) {
    NodoBST* nodo_ricetta = cercaBST(bst, (char*)nome_ricetta);
    IngredienteRicetta* ing = nodo_ricetta->ricetta.ingredienti;
    while (ing != NULL) {
        NodoAVL* nodo_ingrediente = cercaAVL(avl, ing->nome);
        if (nodo_ingrediente == NULL) {
            return false;
        }
        MinHeapIngrediente* heap = &nodo_ingrediente->heap;
        int quantita_totale = 0;
        for (int i = 0; i < nodo_ingrediente->heap.dimensione; i++) {
            quantita_totale += heap->lotto[i].quantita;
        }
        int peso_totale_richiesto = ing->quantita * numero_elementi_ordinati;
        if (quantita_totale < peso_totale_richiesto) {
            return false;
        }
        ing = ing->next;
    }
    return true;
}

void preparazione(const char* nome_ricetta, int numero_elementi_ordinati, int tempo_arrivo) {
    NodoBST* nodo_ricetta = cercaBST(bst, (char*)nome_ricetta);
    IngredienteRicetta* ing = nodo_ricetta->ricetta.ingredienti;
    while (ing != NULL) {
        NodoAVL* nodo_ingrediente = cercaAVL(avl, ing->nome);
        int quantita_richiesta = ing->quantita * numero_elementi_ordinati;
        while (quantita_richiesta > 0) {
            if (nodo_ingrediente->heap.dimensione == 0) {
                return; // Non ci sono abbastanza ingredienti
            }
            IngredienteMinHeap min_ingrediente = rimuoviIngrediente(&nodo_ingrediente->heap);
            if (min_ingrediente.quantita <= quantita_richiesta) {
                quantita_richiesta -= min_ingrediente.quantita;
            } else {
                min_ingrediente.quantita -= quantita_richiesta;
                quantita_richiesta = 0;
                inserisciIngrediente(&nodo_ingrediente->heap, min_ingrediente.scadenza, min_ingrediente.quantita, nodo_ingrediente);
            }
        }
        ing = ing->next;
    }
    inserisciOrdineHeap(heap_ordini_fatti, tempo_arrivo, (char*)nome_ricetta, numero_elementi_ordinati);
}

void verificaOrdini() {
    controllaScadenzaAVL(avl);
    Ordine* ordineCorrente = coda_ordini->testa;
    Ordine* precedente = NULL;
    while (ordineCorrente != NULL) {
        if (fattibilita(ordineCorrente->nome_ricetta, ordineCorrente->quantita)) {
            preparazione(ordineCorrente->nome_ricetta, ordineCorrente->quantita, ordineCorrente->tempo_arrivo);
            if (precedente == NULL) {
                coda_ordini->testa = ordineCorrente->next;
                if (coda_ordini->testa == NULL) {
                    coda_ordini->coda = NULL;
                }
            } else {
                precedente->next = ordineCorrente->next;
                if (precedente->next == NULL) {
                    coda_ordini->coda = precedente;
                }
            }
            Ordine* temp = ordineCorrente;
            ordineCorrente = ordineCorrente->next;
            free(temp);
        } else {
            precedente = ordineCorrente;
            ordineCorrente = ordineCorrente->next;
        }
    }
}

void caricaCamion() {
    if (heapVuotoMinOrdine(heap_ordini_fatti)) {
        printf("camioncino vuoto\n");
        return;
    }
    int capienzaRestante = max_heap_spedizioni->capacita;
    MinHeap* tempHeap = creaMinHeap(heap_ordini_fatti->capacita);
    while (!heapVuotoMinOrdine(heap_ordini_fatti)) {
        OrdineHeap ordine = rimuoviMin(heap_ordini_fatti);
        NodoBST* nodo_ricetta = cercaBST(bst, ordine.ricetta);
        int peso_ordine = calcolaPeso(nodo_ricetta->ricetta, ordine.quantita);
        if (peso_ordine <= capienzaRestante) {
            inserisciSpedizione(max_heap_spedizioni, ordine.ricetta, ordine.tempo_arrivo, ordine.quantita, peso_ordine);
            capienzaRestante -= peso_ordine;
        } else {
            inserisciOrdineHeap(tempHeap, ordine.tempo_arrivo, ordine.ricetta, ordine.quantita);
            break;
        }
    }
    while (!heapVuotoMinOrdine(heap_ordini_fatti)) {
        OrdineHeap ordine = rimuoviMin(heap_ordini_fatti);
        inserisciOrdineHeap(tempHeap, ordine.tempo_arrivo, ordine.ricetta, ordine.quantita);
    }
    while (!heapVuotoMinOrdine(tempHeap)) {
        OrdineHeap ordine = rimuoviMin(tempHeap);
        inserisciOrdineHeap(heap_ordini_fatti, ordine.tempo_arrivo, ordine.ricetta, ordine.quantita);
    }
    liberaMinHeapOrdini(tempHeap);
    if (!heapVuotoMax(max_heap_spedizioni)) {
        while (!heapVuotoMax(max_heap_spedizioni)) {
            Spedizione spedizione = rimuoviMax(max_heap_spedizioni);
            printf("%d %s %d\n", spedizione.istante_arrivo, spedizione.nome, spedizione.quantita);
        }
    }
}

int calcolaPeso(Ricetta ricetta, int numero_elementi_ordinati) {
    int peso = 0;
    IngredienteRicetta* ingrediente = ricetta.ingredienti;
    while (ingrediente != NULL) {
        peso += ingrediente->quantita;
        ingrediente = ingrediente->next;
    }
    peso *= numero_elementi_ordinati;
    return peso;
}

void controllaScadenza(NodoAVL* nodo_ingrediente) {
    if (nodo_ingrediente == NULL) {
        return;
    }
    MinHeapIngrediente* heap = &nodo_ingrediente->heap;
    int i = 0;
    while (i < heap->dimensione) {
        if (heap->lotto[i].scadenza <= tempoCorrente) {
            IngredienteMinHeap scaduto = heap->lotto[i];
            heap->lotto[i] = heap->lotto[--heap->dimensione];
            heapifyIngredienti(heap, i);
        } else {
            i++;
        }
    }
}

void controllaScadenzaAVL(NodoAVL* nodo) {
    if (nodo == NULL) {
        return;
    }
    controllaScadenzaAVL(nodo->sinistro);
    controllaScadenza(nodo);
    controllaScadenzaAVL(nodo->destro);
}

/*  Problemi riscontrati e edge cases:  1) A parità di peso, gli ordini del camioncino vanno per istante di arrivo
*                                       2) Il camioncino passa anche se l'ultima riga è al comando n*(tempoCamion-1) quindi devo fare un ultimo controllo
*                                       3) Nell'example.txt la ciambella 9-3 sostituiva la 5-6, tolto l'inseirmento a priori in Coda FIFO
*                                       4) La liberazione di un nodo nell'AVL e la stampa del minHeap generava problemi nell'example.txt sulla torta 10 1
*                                       5) Rifornimento al tempo 8/9 non va a buon fine in open4 -> facevo lettura fino a 256
*                                       6) Secondo giro di open4 il camion svuotava scorrettamente il minHeapOrdini
*                                       7) Secondo giro di open4 il camion carica due ordini di troppo, ha la capacità per farlo,
*                                          quindi non andavano prodotti -> Camion si ferma al primo che incontra troppo pesante
*                                       8) open5 access violation al primo caricamento del camion, sembra essere un problema nel minHeap ordini
*
*/
//Elenco di tutte le funzioni riguardanti le strutture dati
#include "header.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <limits.h>

//Funzioni min-Heap - Ingredienti
void scambia(IngredienteMinHeap* a, IngredienteMinHeap* b) {
    IngredienteMinHeap temp = *a;
    *a = *b;
    *b = temp;
}

void heapifyIngredienti(MinHeapIngrediente* heap, int i) {
    int piuPiccolo = i;
    int sinistra = 2 * i + 1;
    int destra = 2 * i + 2;
    if (sinistra < heap->dimensione && heap->lotto[sinistra].scadenza < heap->lotto[piuPiccolo].scadenza) {
        piuPiccolo = sinistra;
    }
    if (destra < heap->dimensione && heap->lotto[destra].scadenza < heap->lotto[piuPiccolo].scadenza) {
        piuPiccolo = destra;
    }
    if (piuPiccolo != i) {
        scambia(&heap->lotto[i], &heap->lotto[piuPiccolo]);
        heapifyIngredienti(heap, piuPiccolo);
    }
}

void inserisciIngrediente(MinHeapIngrediente* heap, int scadenza, int quantita, struct NodoAVL* nodo) {
    //printf("Inserendo Ingrediente: Scadenza = %d, Quantita = %d\n", scadenza, quantita); // Debugging
    if (heap->dimensione == heap->capacita) {
        heap->capacita *= 2;
        heap->lotto = (IngredienteMinHeap*) realloc(heap->lotto, heap->capacita * sizeof(IngredienteMinHeap));
    }
    int i = heap->dimensione++;
    heap->lotto[i].scadenza = scadenza;
    heap->lotto[i].quantita = quantita;
    heap->lotto[i].nodoAVL = nodo;  // Imposta il puntatore al nodo AVL
    while (i != 0 && heap->lotto[(i - 1) / 2].scadenza > heap->lotto[i].scadenza) {
        scambia(&heap->lotto[i], &heap->lotto[(i - 1) / 2]);
        i = (i - 1) / 2;
    }
   // printf("Ingrediente inserito: %s, Scadenza = %d, Quantita = %d\n", nodo->nome, scadenza, quantita); // Debugging
    //stampaHeapIngredienti1(heap);
}

IngredienteMinHeap rimuoviIngrediente(MinHeapIngrediente* heap) {
    if (heap->dimensione == 0) {
        IngredienteMinHeap ingredienteVuoto = { INT_MAX, 0, NULL };
        return ingredienteVuoto;
    }
    IngredienteMinHeap radice = heap->lotto[0];
    heap->lotto[0] = heap->lotto[--heap->dimensione];
    heapifyIngredienti(heap, 0);
    return radice;
}

MinHeapIngrediente nuovoHeapIngredienti(int capacita) {
    MinHeapIngrediente heap;
    heap.lotto = (IngredienteMinHeap*) malloc(capacita * sizeof(IngredienteMinHeap));
    if (heap.lotto == NULL) {
        fprintf(stderr, "Errore di allocazione della memoria per lotto\n");
        exit(EXIT_FAILURE);
    }
    heap.dimensione = 0;
    heap.capacita = capacita;
    return heap;
}

void liberaLotto(MinHeapIngrediente* heap) {
    if (heap != NULL && heap->lotto != NULL) {
        free(heap->lotto);
        heap->lotto = NULL;
        heap->dimensione = 0;
        heap->capacita = 0;
        //printf("Heap ingredienti liberato\n");
    }
}

//Funzioni AVL di min-Heap - Ingredienti
void liberaAVL(NodoAVL *root){
    if(root!= NULL) {
        liberaAVL(root->sinistro);
        liberaAVL(root->destro);
        liberaLotto(&root->heap);
        free(root);
        }
}

int valBilancia(NodoAVL *nodo){
    if(nodo==NULL)
        return 0;
    return altezza(nodo->sinistro)-altezza(nodo->destro);
}

int altezza(NodoAVL *nodo) {
    if(nodo==NULL)
        return 0;
    return nodo->altezza;
}

NodoAVL* nuovoAVL(char* nome, int capacita) {
    NodoAVL* nodo = (NodoAVL*)malloc(sizeof(NodoAVL));
    strcpy(nodo->nome, nome);
    nodo->heap = nuovoHeapIngredienti(capacita);
    nodo->sinistro = NULL;
    nodo->destro = NULL;
    nodo->altezza = 1;
    return nodo;
}

NodoAVL* ruotaDestra(NodoAVL *y) {
    NodoAVL *x= y->sinistro;
    NodoAVL *z = x->destro;
    x-> destro=y;
    y-> sinistro= z;
    y->altezza=max(altezza(y->sinistro), altezza((y->destro)))+1;
    x->altezza=max(altezza(y->sinistro), altezza((y->destro)))+1;
    return x;
}

NodoAVL* ruotaSinistra(NodoAVL *x) {
    NodoAVL *y= x->destro;
    NodoAVL *z = y->sinistro;
    y-> sinistro= x;
    x-> destro= z;
    x->altezza=max(altezza(x->sinistro), altezza((x->destro)))+1;
    y->altezza=max(altezza(y->sinistro), altezza((y->destro)))+1;
    return y;
}

NodoAVL* minValueAVL(NodoAVL *nodo) {
    NodoAVL *corrente=nodo;
    while(corrente->sinistro!=NULL)
        corrente=corrente->sinistro;
    return corrente;
}

NodoAVL* eliminaAVL(NodoAVL* root, char *nome) {
    if (root == NULL)
        return root;
    if (strcmp(nome, root->nome) < 0) {
        root->sinistro = eliminaAVL(root->sinistro, nome);
    } else if (strcmp(nome, root->nome) > 0) {
        root->destro = eliminaAVL(root->destro, nome);
    } else {
        if (root->sinistro == NULL || root->destro == NULL) {
            NodoAVL *temp = root->sinistro ? root->sinistro : root->destro;
            liberaLotto(&root->heap);  // Libera la memoria del lotto
            if (temp == NULL) {
                free(root);
                return NULL;
            } else {
                *root = *temp; // Copia il contenuto del nodo non vuoto
                free(temp);
            }
        } else {
            NodoAVL* temp = minValueAVL(root->destro);
            strcpy(root->nome, temp->nome);
            root->heap = temp->heap;
            root->destro = eliminaAVL(root->destro, temp->nome);
        }
    }
    root->altezza = 1 + max(altezza(root->sinistro), altezza(root->destro));
    int bilancio = valBilancia(root);
    if (bilancio > 1 && valBilancia(root->sinistro) >= 0)
        return ruotaDestra(root);
    if (bilancio > 1 && valBilancia(root->sinistro) < 0) {
        root->sinistro = ruotaSinistra(root->sinistro);
        return ruotaDestra(root);
    }
    if (bilancio < -1 && valBilancia(root->destro) <= 0)
        return ruotaSinistra(root);
    if (bilancio < -1 && valBilancia(root->destro) > 0) {
        root->destro = ruotaDestra(root->destro);
        return ruotaSinistra(root);
    }
    return root;
}

NodoAVL* cercaAVL(NodoAVL* nodo, const char* nome) {
    //print_string_info(nome);
    if (nodo == NULL || strcmp(nodo->nome, nome) == 0) {
        //printf("Nodo trovato per ingrediente: %s\n", nome);
        return nodo;
    }
    //printf("Confronto nome ingrediente: %s con nodo corrente: %s\n", nome, nodo->nome);
    if (strcmp(nome, nodo->nome) < 0) {
        return cercaAVL(nodo->sinistro, nome);
    }
    return cercaAVL(nodo->destro, nome);
}


NodoAVL* inserisciAVL(NodoAVL* nodo, char* nome, int scadenza, int quantita, int capacita) {
    //print_string_info(nome);
    if (nodo == NULL) {
        //printf("Creazione nuovo nodo per ingrediente: %s\n", nome);
        NodoAVL* nuovo = nuovoAVL(nome, capacita);
        inserisciIngrediente(&nuovo->heap, scadenza, quantita, nuovo);
        return nuovo;
    }
    //printf("Confronto nome ingrediente: %s con nodo corrente: %s\n", nome, nodo->nome);
    if (strcmp(nome, nodo->nome) < 0) {
        nodo->sinistro = inserisciAVL(nodo->sinistro, nome, scadenza, quantita, capacita);
    } else if (strcmp(nome, nodo->nome) > 0) {
        nodo->destro = inserisciAVL(nodo->destro, nome, scadenza, quantita, capacita);
    } else {
        //printf("Aggiunta ingrediente esistente al nodo AVL: %s\n", nome);
        inserisciIngrediente(&nodo->heap, scadenza, quantita, nodo);
    }
    //verificaInserimento(nodo, nome);
    nodo->altezza = 1 + max(altezza(nodo->sinistro), altezza(nodo->destro));
    return bilanciaAVL(nodo);
}

NodoAVL* bilanciaAVL(NodoAVL* nodo) {
    int bilancio = valBilancia(nodo);
    if (bilancio > 1 && valBilancia(nodo->sinistro) >= 0)
        return ruotaDestra(nodo);
    if (bilancio > 1 && valBilancia(nodo->sinistro) < 0) {
        nodo->sinistro = ruotaSinistra(nodo->sinistro);
        return ruotaDestra(nodo);
    }
    if (bilancio < -1 && valBilancia(nodo->destro) <= 0)
        return ruotaSinistra(nodo);
    if (bilancio < -1 && valBilancia(nodo->destro) > 0) {
        nodo->destro = ruotaDestra(nodo->destro);
        return ruotaSinistra(nodo);
    }
    return nodo;
}

//Funzioni BST - Ricette
void liberaBST(NodoBST* root) {
   if(root!=NULL) {
       liberaBST(root->sinistro);
       liberaBST(root->destro);
       liberaListaIng(root->ricetta.ingredienti);
       free(root);
   }
}

void liberaListaIng(IngredienteRicetta* ingrediente) {
    IngredienteRicetta* temp;
    while(ingrediente!=NULL) {
        temp=ingrediente;
        ingrediente=ingrediente->next;
        free(temp);
    }
}

NodoBST* nuovoBST(Ricetta ricetta) {
    NodoBST* nodo=(NodoBST*)malloc(sizeof(NodoBST));
    nodo->ricetta =ricetta;
    nodo-> sinistro= nodo ->destro=NULL;
    return nodo;
}

NodoBST* minValueBST(NodoBST* nodo) {
    NodoBST* corrente=nodo;
    while(corrente && corrente->sinistro!=NULL)
        corrente=corrente->sinistro;
    return corrente;
}

NodoBST* inserisciBST(NodoBST* nodo, Ricetta ricetta) {
    if (nodo == NULL)
        return nuovoBST(ricetta);
    if (strcmp(ricetta.nome, nodo->ricetta.nome) < 0)
        nodo->sinistro = inserisciBST(nodo->sinistro, ricetta);
    else if (strcmp(ricetta.nome, nodo->ricetta.nome) > 0)
        nodo->destro = inserisciBST(nodo->destro, ricetta);
    return nodo;
}

NodoBST* cercaBST(NodoBST* nodo, char* nome) {
    if (nodo == NULL || strcmp(nodo->ricetta.nome, nome) == 0)
        return nodo;
    if (strcmp(nome, nodo->ricetta.nome) < 0)
        return cercaBST(nodo->sinistro, nome);
    return cercaBST(nodo->destro,nome);
}

NodoBST* eliminaBST(NodoBST* root, char* nome) {
    if (root == NULL)
        return root;
    if (strcmp(nome, root->ricetta.nome) < 0)
        root->sinistro = eliminaBST(root->sinistro, nome);
    else if (strcmp(nome, root->ricetta.nome) > 0)
        root->destro = eliminaBST(root->destro, nome);
    else {
        if (root->sinistro == NULL) {
            NodoBST* temp = root->destro;
            free(root);
            return temp;
        } else if (root->destro == NULL) {
            NodoBST* temp = root->sinistro;
            free(root);
            return temp;
        }
        NodoBST* temp = minValueBST(root->destro);
        root->ricetta = temp->ricetta;
        root->destro = eliminaBST(root->destro, temp->ricetta.nome);
    }
    return root;
}

//Funzioni Coda FIFO - Ordini da Fare
void liberaCoda(CodaOrdini* coda) {
    Ordine* temp;
    while(coda->testa!=NULL) {
        temp=coda->testa;
        coda->testa=coda->testa->next;
        free(temp);
    }
    free(coda);
}

void aggiungiCoda(CodaOrdini* coda, const char* nome_ricetta, int quantita, int tempo_arrivo) {
    Ordine* nuovoOrdine = (Ordine*)malloc(sizeof(Ordine));
    if (nuovoOrdine == NULL) {
        fprintf(stderr, "Errore di allocazione della memoria per nuovoOrdine\n");
        exit(EXIT_FAILURE);
    }
    nuovoOrdine->tempo_arrivo = tempo_arrivo;
    strcpy(nuovoOrdine->nome_ricetta, nome_ricetta);
    nuovoOrdine->quantita = quantita;
    nuovoOrdine->next = NULL;
    if (coda->coda == NULL) {
        coda->testa = nuovoOrdine;
        coda->coda = nuovoOrdine;
    } else {
        coda->coda->next = nuovoOrdine;
        coda->coda = nuovoOrdine;
    }
    //printf("Ordine aggiunto con successo\n"); // Debugging
}

int codaVuota(CodaOrdini* coda) {
    return coda->testa==NULL;
}

CodaOrdini* creaCoda() {
    CodaOrdini* coda=(CodaOrdini*)malloc(sizeof(CodaOrdini));
    coda->testa=NULL;
    coda->coda=NULL;
    return coda;
}

Ordine* rimuoviCoda(CodaOrdini* coda) {
    if (coda->testa == NULL) {
        return NULL;
    }
    Ordine* ordineRimosso = coda->testa;
    coda->testa = coda->testa->next;
    if (coda->testa == NULL) {
        coda->coda = NULL;
    }
    free(ordineRimosso);
    return coda->testa;
}

//Funzioni minHeap - Ordini Fatti
void liberaMinHeapOrdini(MinHeap* heap) {
    free(heap->ordini);
    free(heap);
}

void scambiaOrdini(OrdineHeap* a, OrdineHeap* b) {
    OrdineHeap temp= *a;
    *a=*b;
    *b=temp;
}

void heapifyOrdini(MinHeap* heap, int i) {
    int minore = i;
    int sx = 2 * i + 1;
    int dx = 2 * i + 2;
    if (sx < heap->dimensione && heap->ordini[sx].tempo_arrivo < heap->ordini[minore].tempo_arrivo)
        minore = sx;
    if (dx < heap->dimensione && heap->ordini[dx].tempo_arrivo < heap->ordini[minore].tempo_arrivo)
        minore = dx;
    if (minore != i) {
        scambiaOrdini(&heap->ordini[i], &heap->ordini[minore]);
        heapifyOrdini(heap, minore);
    }
}

void inserisciOrdineHeap(MinHeap* heap, int tempo_arrivo, char* ricetta, int quantita) {
    if(heap->dimensione==heap->capacita) {
        heap->capacita*=2;
        heap->ordini=(OrdineHeap*)realloc(heap->ordini, heap->capacita*sizeof(OrdineHeap));
    }
    int i=heap->dimensione++;
    heap->ordini[i].tempo_arrivo=tempo_arrivo;
    strcpy(heap->ordini[i].ricetta, ricetta);
    heap->ordini[i].quantita=quantita;
    while(i!=0 && heap->ordini[(i-1)/2].tempo_arrivo > heap->ordini[i].tempo_arrivo) {
        scambiaOrdini(&heap->ordini[i], &heap->ordini[(i-1)/2]);
        i=(i-1)/2;
    }
}

int heapVuotoMinOrdine(MinHeap* heap) {
    return heap->dimensione==0;
}

MinHeap* creaMinHeap(int capacita) {
    MinHeap* heap = (MinHeap*)malloc(sizeof(MinHeap));
    if (heap == NULL) {
        fprintf(stderr, "Errore di allocazione della memoria per MinHeap\n");
        exit(EXIT_FAILURE);
    }
    heap->ordini = (OrdineHeap*)malloc(capacita * sizeof(OrdineHeap));
    if (heap->ordini == NULL) {
        fprintf(stderr, "Errore di allocazione della memoria per gli ordini del MinHeap\n");
        exit(EXIT_FAILURE);
    }
    heap->dimensione = 0;
    heap->capacita = capacita;
    return heap;
}

OrdineHeap rimuoviMin(MinHeap* heap) {
    if (heap->dimensione == 0) {
        // Gestisci errore se il min-heap è vuoto
        fprintf(stderr, "Errore: tentativo di rimuovere da un min-heap vuoto\n");
        OrdineHeap ordineVuoto;
        strcpy(ordineVuoto.ricetta, "");
        ordineVuoto.quantita = 0;
        ordineVuoto.tempo_arrivo = 0;
        return ordineVuoto;
    }
    OrdineHeap min = heap->ordini[0];
    heap->ordini[0] = heap->ordini[heap->dimensione - 1];
    heap->dimensione--;
    heapifyOrdini(heap, 0); // Funzione che mantiene la proprietà del min-heap
    return min;
}

//Funzioni maxHeap - Camioncino Spedizioni
void heapifySpedizioni(MaxHeapSpedizioni* heap, int i) {
    int maggiore = i;
    int sinistro = 2 * i + 1;
    int destro = 2 * i + 2;
    // Condizione per peso maggiore
    if (sinistro < heap->dimensione && heap->spedizioni[sinistro].peso > heap->spedizioni[maggiore].peso)
        maggiore = sinistro;
    // Condizione per peso uguale ma istante di arrivo minore
    else if (sinistro < heap->dimensione && heap->spedizioni[sinistro].peso == heap->spedizioni[maggiore].peso &&
             heap->spedizioni[sinistro].istante_arrivo < heap->spedizioni[maggiore].istante_arrivo)
        maggiore = sinistro;
    // Condizione per peso maggiore
    if (destro < heap->dimensione && heap->spedizioni[destro].peso > heap->spedizioni[maggiore].peso)
        maggiore = destro;
    // Condizione per peso uguale ma istante di arrivo minore
    else if (destro < heap->dimensione && heap->spedizioni[destro].peso == heap->spedizioni[maggiore].peso &&
             heap->spedizioni[destro].istante_arrivo < heap->spedizioni[maggiore].istante_arrivo)
        maggiore = destro;
    if (maggiore != i) {
        Spedizione temp = heap->spedizioni[i];
        heap->spedizioni[i] = heap->spedizioni[maggiore];
        heap->spedizioni[maggiore] = temp;
        heapifySpedizioni(heap, maggiore);
    }
}

void inserisciSpedizione(MaxHeapSpedizioni* heap, char* nome, int istante_arrivo, int quantita, int peso) {
    if (heap->dimensione == heap->capacita) {
        heap->capacita *= 2;
        heap->spedizioni = (Spedizione*) realloc(heap->spedizioni, heap->capacita * sizeof(Spedizione));
    }
    int i = heap->dimensione++;
    strcpy(heap->spedizioni[i].nome, nome);
    heap->spedizioni[i].istante_arrivo = istante_arrivo;
    heap->spedizioni[i].quantita = quantita;
    heap->spedizioni[i].peso = peso;
    while (i != 0) {
        int parent = (i - 1) / 2;
        if (heap->spedizioni[parent].peso < heap->spedizioni[i].peso) {
            Spedizione temp = heap->spedizioni[i];
            heap->spedizioni[i] = heap->spedizioni[parent];
            heap->spedizioni[parent] = temp;
            i = parent;
        } else if (heap->spedizioni[parent].peso == heap->spedizioni[i].peso &&
                   heap->spedizioni[parent].istante_arrivo > heap->spedizioni[i].istante_arrivo) {
            Spedizione temp = heap->spedizioni[i];
            heap->spedizioni[i] = heap->spedizioni[parent];
            heap->spedizioni[parent] = temp;
            i = parent;
                   } else {
                       break;
                   }
    }
}

void liberaMaxHeap(MaxHeapSpedizioni* heap) {
    free(heap->spedizioni);
}

MaxHeapSpedizioni* creaMaxHeap(int capacita) {
    MaxHeapSpedizioni* heap = (MaxHeapSpedizioni*)malloc(sizeof(MaxHeapSpedizioni));
    heap->spedizioni = (Spedizione*) malloc(capacita * sizeof(Spedizione));
    heap->dimensione = 0;
    heap->capacita = capacita;
    return heap;
}

Spedizione rimuoviMax(MaxHeapSpedizioni* heap) {
    if (heap->dimensione<=0) {
        Spedizione nullSpedizione = {"", 0, 0, 0};
        return nullSpedizione;
    }
    Spedizione root=heap->spedizioni[0];
    if (heap->dimensione==1) {
        heap->dimensione--;
        return root;
    }
    heap->spedizioni[0]=heap->spedizioni[--heap->dimensione];
    heapifySpedizioni(heap, 0);
    return root;
}

int heapVuotoMax(MaxHeapSpedizioni* heap) {
    return heap->dimensione == 0;
}


#include "header.h"
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>

// Funzione per verificare la correttezza del MinHeap
bool verificaMinHeap(MinHeapIngrediente* heap) {
    for (int i = 0; i <= (heap->dimensione - 2) / 2; i++) {
        if (heap->lotto[i].scadenza > heap->lotto[2 * i + 1].scadenza) {
            return false;
        }
        if (2 * i + 2 < heap->dimensione && heap->lotto[i].scadenza > heap->lotto[2 * i + 2].scadenza) {
            return false;
        }
    }
    return true;
}

// Funzione per stampare lo stato del MinHeap
void testHeapOrder(MinHeapIngrediente* heap) {
    if (verificaMinHeap(heap)) {
        printf("L'heap e un min-heap valido.\n");
    } else {
        printf("L'heap non e un min-heap valido.\n");
    }
    for (int i = 0; i < heap->dimensione; i++) {
        printf("Scadenza: %d, Quantita: %d\n", heap->lotto[i].scadenza, heap->lotto[i].quantita);
    }
}

// Funzioni di Test Migliorate
void testMinHeapInserimento() {
    printf("\n--- Test Inserimento ---\n");
    MinHeapIngrediente heap = nuovoHeapIngredienti(2);
    NodoAVL* nodo = NULL;
    printf("Inserimento elemento con scadenza 100, quantita 10\n");
    inserisciIngrediente(&heap, 100, 10, nodo);
    printf("Inserimento elemento con scadenza 99, quantita 11\n");
    inserisciIngrediente(&heap, 99, 11, nodo);
    printf("Inserimento elemento con scadenza 4, quantita 12\n");
    inserisciIngrediente(&heap, 4, 12, nodo);
    printf("Stato MinHeapIngrediente dopo inserimenti:\n");
    testHeapOrder(&heap);
    liberaLotto(&heap);
}

void testMinHeapRimozione() {
    printf("\n--- Test Rimozione ---\n");
    MinHeapIngrediente heap = nuovoHeapIngredienti(2);
    NodoAVL* nodo = NULL;
    printf("Inserimento elemento con scadenza 100, quantita 10\n");
    inserisciIngrediente(&heap, 100, 10, nodo);
    printf("Inserimento elemento con scadenza 99, quantita 11\n");
    inserisciIngrediente(&heap, 99, 11, nodo);
    printf("Inserimento elemento con scadenza 4, quantita 12\n");
    inserisciIngrediente(&heap, 4, 12, nodo);
    printf("Stato MinHeapIngrediente prima della rimozione:\n");
    testHeapOrder(&heap);
    IngredienteMinHeap rimosso = rimuoviIngrediente(&heap);
    printf("Rimosso ingrediente: scadenza = %d, quantita = %d\n", rimosso.scadenza, rimosso.quantita);
    printf("Stato MinHeapIngrediente dopo rimozione:\n");
    testHeapOrder(&heap);
    liberaLotto(&heap);
}

void testMinHeapOverflow() {
    printf("\n--- Test Overflow ---\n");
    MinHeapIngrediente heap = nuovoHeapIngredienti(2);
    NodoAVL* nodo = NULL;
    for (int i = 0; i < 10; i++) {
        printf("Inserimento elemento con scadenza %d, quantita 10\n", i + 1);
        inserisciIngrediente(&heap, i + 1, 10, nodo);
    }
    printf("Stato MinHeapIngrediente dopo multipli inserimenti (overflow):\n");
    testHeapOrder(&heap);
    liberaLotto(&heap);
}

void testMinHeapInit() {
    printf("\n--- Test Inizializzazione ---\n");
    MinHeapIngrediente heap = nuovoHeapIngredienti(10);
    if (heap.dimensione == 0 && heap.capacita == 10) {
        printf("Inizializzazione corretta.\n");
    } else {
        printf("Errore di inizializzazione.\n");
    }
    liberaLotto(&heap);
}

void testUsoParzialeIngrediente() {
    printf("\n--- Test Uso Parziale Ingrediente ---\n");
    MinHeapIngrediente heap = nuovoHeapIngredienti(3);
    NodoAVL* nodo = NULL;
    printf("Inserimento elemento con scadenza 100, quantita 10\n");
    inserisciIngrediente(&heap, 100, 10, nodo);
    printf("Stato dopo inserimento:\n");
    testHeapOrder(&heap);
    printf("Inserimento elemento con scadenza 99, quantita 11\n");
    inserisciIngrediente(&heap, 99, 11, nodo);
    printf("Stato dopo inserimento:\n");
    testHeapOrder(&heap);
    printf("Inserimento elemento con scadenza 4, quantita 12\n");
    inserisciIngrediente(&heap, 4, 12, nodo);
    printf("Stato dopo inserimento:\n");
    testHeapOrder(&heap);
    printf("Stato MinHeapIngrediente dopo inserimenti:\n");
    testHeapOrder(&heap);
    printf("Uso di parte dell'ingrediente con scadenza 4\n");
    IngredienteMinHeap rimosso = rimuoviIngrediente(&heap);
    printf("Rimosso ingrediente: scadenza = %d, quantita = %d\n", rimosso.scadenza, rimosso.quantita);
    int quantita_usata = 12; // Usare tutto l'ingrediente con scadenza 4
    printf("Utilizzata quantita %d\n", quantita_usata);
    printf("Stato MinHeapIngrediente dopo rimozione dell'ingrediente con scadenza 4:\n");
    testHeapOrder(&heap);
    quantita_usata = 6;
    printf("Uso di parte dell'ingrediente con scadenza 99\n");
    rimosso = rimuoviIngrediente(&heap);
    printf("Rimosso ingrediente: scadenza = %d, quantita = %d\n", rimosso.scadenza, rimosso.quantita);
    rimosso.quantita -= quantita_usata;
    printf("Rimanente ingrediente con scadenza %d: quantita %d\n", rimosso.scadenza, rimosso.quantita);
    if (rimosso.quantita > 0) {
        inserisciIngrediente(&heap, rimosso.scadenza, rimosso.quantita, nodo);
    }
    printf("Stato MinHeapIngrediente dopo reinserimento dell'ingrediente con scadenza 99:\n");
    testHeapOrder(&heap);
    printf("Stato MinHeapIngrediente dopo uso parziale:\n");
    testHeapOrder(&heap);
    liberaLotto(&heap);
}

void testRifornimentoRicetta() {
    printf("\n--- Test Rifornimento e Preparazione Ricetta ---\n");
    NodoAVL* nodo = nuovoAVL("IngredienteTest", 10);
    avl = nodo;
    printf("Rifornimento con scadenza 100, quantita 10\n");
    inserisciIngrediente(&nodo->heap, 100, 10, nodo);
    printf("Stato dopo rifornimento:\n");
    testHeapOrder(&nodo->heap);
    printf("Rifornimento con scadenza 99, quantita 10\n");
    inserisciIngrediente(&nodo->heap, 99, 10, nodo);
    printf("Stato dopo rifornimento:\n");
    testHeapOrder(&nodo->heap);
    printf("Rifornimento con scadenza 4, quantita 10\n");
    inserisciIngrediente(&nodo->heap, 4, 10, nodo);
    printf("Stato dopo rifornimento:\n");
    testHeapOrder(&nodo->heap);
    printf("Aggiunta ricetta 'RicettaTest' con 15 di 'IngredienteTest'\n");
    Ricetta nuova_ricetta;
    strcpy(nuova_ricetta.nome, "RicettaTest");
    IngredienteRicetta* ingrediente_ricetta = (IngredienteRicetta*)malloc(sizeof(IngredienteRicetta));
    strcpy(ingrediente_ricetta->nome, "IngredienteTest");
    ingrediente_ricetta->quantita = 15;
    ingrediente_ricetta->next = NULL;
    nuova_ricetta.ingredienti = ingrediente_ricetta;
    bst = inserisciBST(bst, nuova_ricetta);
    printf("Ricetta aggiunta\n");
    printf("Preparazione della ricetta 'RicettaTest'\n");
    printf("Stato MinHeapIngrediente prima della preparazione:\n");
    testHeapOrder(&nodo->heap);
    //preparazione("RicettaTest", 1);
    printf("Stato MinHeapIngrediente dopo la preparazione:\n");
    testHeapOrder(&nodo->heap);
    liberaAVL(avl);
    liberaBST(bst);
    free(ingrediente_ricetta);
}

void testAggiungiRimuoviIngredienti_AVL() {
    NodoAVL *avl = NULL;
    avl = inserisciAVL(avl, "Farina", 10, 5, 10);
    printf("Aggiunto Farina con scadenza 10 e quantita 5\n");
    avl = inserisciAVL(avl, "Farina", 5, 10, 10);
    printf("Aggiunto Farina con scadenza 5 e quantita 10\n");
    stampaAVL1(avl);
    IngredienteMinHeap rimosso = rimuoviIngrediente(&avl->heap);
    printf("Rimosso Farina con scadenza %d e quantita %d\n", rimosso.scadenza, rimosso.quantita);
    stampaAVL1(avl);
    rimosso = rimuoviIngrediente(&avl->heap);
    printf("Rimosso Farina con scadenza %d e quantita %d\n", rimosso.scadenza, rimosso.quantita);
    stampaAVL1(avl);
    avl = eliminaAVL(avl, "Farina");
    printf("Nodo Farina rimosso\n");
    if (avl == NULL) {
        printf("AVL e vuoto\n");
    } else {
        stampaAVL1(avl);
    }
}

void testDeallocazioneAVL() {
    avl = NULL;
    tempoCorrente = 0;
    avl = inserisciAVL(avl, "Ingrediente1", 3, 10, 10);
    avl = inserisciAVL(avl, "Ingrediente1", 6, 15, 10);
    printf("Stato iniziale AVL:\n");
    stampaAVL1(avl);
    tempoCorrente = 3;
    NodoAVL* nodo_ingrediente = cercaAVL(avl, "Ingrediente1");
    if (nodo_ingrediente != NULL) {
        controllaScadenza(nodo_ingrediente);
    }
    printf("\nStato AVL dopo aver impostato il tempo a 3:\n");
    stampaAVL1(avl);
    tempoCorrente = 6;
    nodo_ingrediente = cercaAVL(avl, "Ingrediente1");
    if (nodo_ingrediente != NULL) {
        controllaScadenza(nodo_ingrediente);
    }
    printf("\nStato AVL dopo aver impostato il tempo a 6:\n");
    if (avl != NULL) {
        stampaAVL1(avl);
    } else {
        printf("AVL e vuoto\n");
    }
}

void testMinHeapIngrediente() {
    testMinHeapInserimento();
    testMinHeapRimozione();
    testMinHeapOverflow();
    testMinHeapInit();
}

void testCodaOrdini() {
    CodaOrdini* coda = creaCoda();
    printf("Test Coda Ordini\n");
    aggiungiCoda(coda, "Ciambella", 6, 5);
    stampaCodaFIFO(coda);
    aggiungiCoda(coda, "Profiterole", 3, 6);
    stampaCodaFIFO(coda);
    aggiungiCoda(coda, "Ciambella", 3, 9);
    stampaCodaFIFO(coda);
    Ordine* corrente = coda->testa;
    liberaCoda(coda);
}

void verificaInserimento(NodoAVL* nodo, const char* nome) {
    NodoAVL* risultato = cercaAVL(nodo, nome);
    if (risultato != NULL) {
        printf("Verifica riuscita: Ingrediente '%s' è stato inserito correttamente.\n", nome);
    } else {
        printf("Verifica fallita: Ingrediente '%s' non è stato trovato.\n", nome);
    }
}

//Funzioni di stampa
void stampaHeapIngredienti1(MinHeapIngrediente* heap) {
    for (int i = 0; i < heap->dimensione; i++) {
        printf("  Ingrediente scadenza: %d, Quantita: %d\n", heap->lotto[i].scadenza, heap->lotto[i].quantita);
    }
}

void stampaHeapIngredienti2(MinHeapIngrediente* heap, int* count) {
    for (int i = 0; i < heap->dimensione; i++) {
        printf("  Ingrediente scadenza: %d, Quantita: %d\n", heap->lotto[i].scadenza, heap->lotto[i].quantita);
        (*count)++;
    }
}

void stampaAVL1(NodoAVL* nodo) {
    if (nodo == NULL) {
        return;
    }
    stampaAVL1(nodo->sinistro);
    printf("Ingrediente: %s\n", nodo->nome);
    if (nodo->heap.lotto != NULL) {
        stampaHeapIngredienti1(&nodo->heap);
    } else {
        printf("Heap degli ingredienti e vuoto o non allocato.\n");
    }
    stampaAVL1(nodo->destro);
}


// Funzione di supporto per stampare l'AVL e contare gli elementi
void stampaAVL2(NodoAVL* nodo, int* count) {
    if (nodo == NULL) {
        return;
    }
    stampaAVL2(nodo->sinistro, count);
    printf("Ingrediente: %s\n", nodo->nome);
    if (nodo->heap.lotto != NULL) {
        stampaHeapIngredienti2(&nodo->heap, count);
    } else {
        printf("Heap degli ingredienti e vuoto o non allocato.\n");
    }
    stampaAVL2(nodo->destro, count);
}

void stampaBST1(NodoBST* nodo) {
    if (nodo == NULL) {
        return;
    }
    stampaBST1(nodo->sinistro);
    printf("Ricetta: %s\n", nodo->ricetta.nome);
    IngredienteRicetta* ing = nodo->ricetta.ingredienti;
    while (ing) {
        printf("  Ingrediente: %s, Quantita: %d\n", ing->nome, ing->quantita);
        ing = ing->next;
    }
    stampaBST1(nodo->destro);
}

// Funzione di supporto per stampare il BST delle ricette e contare gli elementi
void stampaBST2(NodoBST* nodo, int* count) {
    if (nodo == NULL) {
        return;
    }
    stampaBST2(nodo->sinistro, count);
    printf("Ricetta: %s\n", nodo->ricetta.nome);
    int peso = 0;
    IngredienteRicetta* ing = nodo->ricetta.ingredienti;
    while (ing) {
        printf("  Ingrediente: %s, Quantita: %d\n", ing->nome, ing->quantita);
        peso += ing->quantita;
        ing = ing->next;
    }
    printf("Peso %s di %d\n", nodo->ricetta.nome, peso);
    (*count)++;
    stampaBST2(nodo->destro, count);
}

// Funzione di supporto per stampare la coda FIFO degli ordini e contare gli elementi
int stampaCodaFIFO(CodaOrdini* coda) {
    int count = 0;
    printf("Coda FIFO degli ordini:\n");
    Ordine* corrente = coda->testa;
    while (corrente) {
        printf("  Ordine: Tempo arrivo: %d, Ricetta: %s, Quantita: %d\n", corrente->tempo_arrivo, corrente->nome_ricetta, corrente->quantita);
        corrente = corrente->next;
        count++;
    }
    return count;
}

// Funzione di supporto per stampare il min-heap degli ordini fatti e contare gli elementi
void stampaMinHeapOrdini(MinHeap* heap) {
    printf("Min-heap degli ordini fatti (Dimensione: %d):\n", heap->dimensione);
    for (int i = 0; i < heap->dimensione; i++) {
        printf("  Ordine ricetta: %s, Quantita: %d, Tempo arrivo: %d\n", heap->ordini[i].ricetta, heap->ordini[i].quantita, heap->ordini[i].tempo_arrivo);
    }
}

// Funzione di supporto per stampare il max-heap delle spedizioni e contare gli elementi
void stampaMaxHeapSpedizioni(MaxHeapSpedizioni* heap) {
    printf("Max-heap delle spedizioni (Dimensione: %d):\n", heap->dimensione);
    for (int i = 0; i < heap->dimensione; i++) {
        printf("  Spedizione: %s, Quantita: %d, Peso: %d, Istante arrivo: %d\n", heap->spedizioni[i].nome, heap->spedizioni[i].quantita, heap->spedizioni[i].peso, heap->spedizioni[i].istante_arrivo);
    }
}

void print_string_info(const char* str) {
    printf("Stringa: '%s', Lunghezza: %zu\n", str, strlen(str));
}

// Funzione principale per stampare tutte le strutture e contare gli elementi
void stampaTutto() {
    printf("\nStato corrente delle strutture dati:\n");
    int count = 0;
    if (avl != NULL) {
        stampaAVL2(avl, &count);
        printf("Numero di ingredienti AVL: %d\n", count);
    } else {
        printf("AVL e vuoto.\n");
    }
    count = 0;
    if (bst != NULL) {
        stampaBST2(bst, &count);
        printf("Numero di ricette BST: %d\n", count);
    } else {
        printf("BST e vuoto.\n");
    }
    if (coda_ordini != NULL) {
        count = stampaCodaFIFO(coda_ordini);
        printf("Numero di ordini nella coda FIFO: %d\n", count);
    } else {
        printf("Coda degli ordini e vuota.\n");
    }
    if (heap_ordini_fatti != NULL) {
        stampaMinHeapOrdini(heap_ordini_fatti);
    } else {
        printf("Min-heap degli ordini fatti e vuoto.\n");
    }
    if (max_heap_spedizioni != NULL) {
        stampaMaxHeapSpedizioni(max_heap_spedizioni);
    } else {
        printf("Max-heap delle spedizioni e vuoto.\n");
    }
    printf("Istante di tempo corrente: %d\n", tempoCorrente);
}
**/
